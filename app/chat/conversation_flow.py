"""
M√≥dulo para manejar el flujo de conversaci√≥n con usuarios
"""
from typing import Dict, Any, Optional, Tuple
import logging
from datetime import datetime, timedelta
import asyncio
from app.models.financial_model import financial_model
from app.views.financial_report import report_generator
from app.external_apis.maga import CanalComercializacion
from app.database.firebase import firebase_manager, FirebaseError
from app.external_apis.maga_precios import maga_api
from app.utils.text import normalize_crop, sanitize_data
from app.analysis.financial import ProyectoAgricola, financial_analyzer

logger = logging.getLogger(__name__)

class ConversationState:
    """Estado de la conversaci√≥n"""
    def __init__(self, state: str = 'START', data: Dict[str, Any] = None):
        self.state = state
        self.data = data or {}
        self.last_interaction = datetime.now()
        self.session_id = None
        
    def is_expired(self, timeout: timedelta = timedelta(minutes=30)) -> bool:
        """Verifica si la conversaci√≥n ha expirado"""
        return datetime.now() - self.last_interaction > timeout
        
    def update(self, state: Optional[str] = None, **kwargs):
        """Actualiza el estado"""
        if state:
            self.state = state
        self.data.update(kwargs)
        self.last_interaction = datetime.now()
        
    def to_dict(self) -> Dict[str, Any]:
        """Convierte el estado a diccionario"""
        return {
            'state': self.state,
            'data': self.data,
            'last_interaction': self.last_interaction.isoformat(),
            'session_id': self.session_id
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ConversationState':
        """Crea un estado desde un diccionario"""
        state = cls(
            state=data.get('state', 'START'),
            data=data.get('data', {})
        )
        state.last_interaction = datetime.fromisoformat(
            data.get('last_interaction', datetime.now().isoformat())
        )
        state.session_id = data.get('session_id')
        return state

class ConversationFlow:
    """Maneja el flujo de conversaci√≥n con usuarios"""
    
    def __init__(self):
        """Inicializa el manejador de conversaci√≥n"""
        
        # Estados de la conversaci√≥n
        self.STATES = {
            'START': 'start',
            'GET_CROP': 'get_crop',
            'GET_AREA': 'get_area',
            'GET_CHANNEL': 'get_channel',
            'GET_IRRIGATION': 'get_irrigation',
            'GET_LOCATION': 'get_location',
            'SHOW_REPORT': 'show_report',
            'ASK_LOAN': 'ask_loan',
            'SHOW_LOAN': 'show_loan',
            'CONFIRM_LOAN': 'confirm_loan',
            'DONE': 'done'
        }
        
        # Comandos especiales
        self.SPECIAL_COMMANDS = {
            'reiniciar': 'START',
            'menu': 'START',
            'ayuda': 'HELP',
            'hola': 'START'
        }
        
        # Mapeo de canales de comercializaci√≥n
        self.channel_mapping = {
            # N√∫meros
            '1': CanalComercializacion.MAYORISTA,
            '2': CanalComercializacion.COOPERATIVA, 
            '3': CanalComercializacion.EXPORTACION,
            '4': CanalComercializacion.MERCADO_LOCAL,
            # Texto exacto
            'mayorista': CanalComercializacion.MAYORISTA,
            'cooperativa': CanalComercializacion.COOPERATIVA,
            'exportacion': CanalComercializacion.EXPORTACION,
            'exportaci√≥n': CanalComercializacion.EXPORTACION,
            'mercado local': CanalComercializacion.MERCADO_LOCAL,
            # Variaciones comunes
            'mayor': CanalComercializacion.MAYORISTA,
            'coop': CanalComercializacion.COOPERATIVA,
            'export': CanalComercializacion.EXPORTACION,
            'mercado': CanalComercializacion.MERCADO_LOCAL,
            'local': CanalComercializacion.MERCADO_LOCAL
        }
        
        # Mapeo de sistemas de riego
        self.irrigation_mapping = {
            # N√∫meros
            '1': 'gravedad',
            '2': 'aspersion',
            '3': 'goteo',
            '4': 'temporal',
            # Texto exacto
            'gravedad': 'gravedad',
            'aspersion': 'aspersion',
            'aspersi√≥n': 'aspersion',
            'goteo': 'goteo',
            'temporal': 'temporal',
            # Variaciones comunes
            'por gravedad': 'gravedad',
            'por aspersion': 'aspersion',
            'por aspersi√≥n': 'aspersion',
            'por goteo': 'goteo',
            'lluvia': 'temporal',
            'natural': 'temporal',
            'ninguno': 'temporal'
        }
    
    async def handle_message(self, phone: str, message: str) -> str:
        """
        Maneja un mensaje entrante
        
        Args:
            phone: N√∫mero de tel√©fono del usuario
            message: Mensaje recibido
            
        Returns:
            str: Respuesta al usuario
        """
        try:
            # Obtener o crear estado
            state = await self._get_state(phone)
            
            # Verificar timeout
            if state.is_expired():
                await self._reset_state(phone)
                return "üëã ¬°Hola de nuevo! Tu sesi√≥n anterior expir√≥. Empecemos de nuevo:\n\n¬øQu√© cultivo planeas sembrar?"
            
            # Procesar mensaje
            message = message.strip().lower()
            
            # Verificar comandos especiales
            if message in self.SPECIAL_COMMANDS:
                new_state = self.SPECIAL_COMMANDS[message]
                if new_state == 'HELP':
                    return self._get_help_message(state.state)
                state.update(state='START')
                await self._save_state(phone, state)
                return "üëã ¬°Empecemos de nuevo!\n\n¬øQu√© cultivo planeas sembrar?"
            
            # Procesar seg√∫n el estado actual
            response = await self._process_state(state, message)
            
            # Guardar estado actualizado
            await self._save_state(phone, state)
            
            return response
            
        except FirebaseError as e:
            logger.error(f"Error de Firebase: {str(e)}")
            return "üòï Lo siento, estamos teniendo problemas t√©cnicos. Por favor, intenta m√°s tarde."
            
        except Exception as e:
            logger.error(f"Error procesando mensaje: {str(e)}")
            return "üòï Hubo un error inesperado. Por favor, intenta de nuevo o escribe 'reiniciar'."
    
    async def _process_state(self, state: ConversationState, message: str) -> str:
        """Procesa el mensaje seg√∫n el estado actual"""
        try:
            if state.state == 'START' or state.state == 'GET_CROP':
                # Normalizar y validar cultivo
                cultivo = normalize_crop(message)
                state.update('GET_AREA', cultivo=cultivo)
                return "üìè ¬øCu√°ntas hect√°reas planeas sembrar?"
                
            elif state.state == 'GET_AREA':
                try:
                    area = float(message.replace(',', '.'))
                    if area <= 0:
                        return "‚ùå El √°rea debe ser mayor a 0. Intenta de nuevo:"
                    if area > 1000:
                        return "‚ùå El √°rea parece muy grande. Por favor verifica e intenta de nuevo:"
                    state.update('GET_CHANNEL', area=area)
                    return ("üè™ ¬øC√≥mo planeas comercializar tu cosecha?\n\n"
                           "1. Mayorista\n"
                           "2. Cooperativa\n"
                           "3. Exportaci√≥n\n"
                           "4. Mercado Local")
                except ValueError:
                    return "‚ùå Por favor ingresa un n√∫mero v√°lido de hect√°reas:"
                    
            elif state.state == 'GET_CHANNEL':
                channel = self.channel_mapping.get(message)
                if not channel:
                    return ("‚ùå Por favor selecciona una opci√≥n v√°lida:\n\n"
                           "1. Mayorista\n"
                           "2. Cooperativa\n"
                           "3. Exportaci√≥n\n"
                           "4. Mercado Local")
                state.update('GET_IRRIGATION', channel=channel)
                return ("üíß ¬øQu√© sistema de riego utilizar√°s?\n\n"
                       "1. Gravedad\n"
                       "2. Aspersi√≥n\n"
                       "3. Goteo\n"
                       "4. Temporal (lluvia)")
                       
            elif state.state == 'GET_IRRIGATION':
                irrigation = self.irrigation_mapping.get(message)
                if not irrigation:
                    return ("‚ùå Por favor selecciona una opci√≥n v√°lida:\n\n"
                           "1. Gravedad\n"
                           "2. Aspersi√≥n\n"
                           "3. Goteo\n"
                           "4. Temporal (lluvia)")
                state.update('GET_LOCATION', irrigation=irrigation)
                return "üìç ¬øEn qu√© departamento est√° ubicado el terreno?"
                
            elif state.state == 'GET_LOCATION':
                # Aqu√≠ podr√≠amos validar contra una lista de departamentos
                state.update('SHOW_REPORT', location=message)
                
                # Crear proyecto y analizar
                proyecto = ProyectoAgricola(
                    cultivo=state.data['cultivo'],
                    hectareas=state.data['area'],
                    precio_actual=maga_api.get_precio(state.data['cultivo']),
                    metodo_riego=state.data['irrigation'],
                    ubicacion={'department': state.data['location']}
                )
                
                analysis = await financial_analyzer.analizar_proyecto(
                    proyecto,
                    session_id=state.session_id
                )
                
                # Generar reporte
                report = report_generator.generate_report(analysis)
                state.update('ASK_LOAN', analysis=analysis)
                
                return (f"{report}\n\n"
                       "¬øTe gustar√≠a solicitar un pr√©stamo para este proyecto? (s√≠/no)")
                       
            elif state.state == 'ASK_LOAN':
                if message in ['si', 's√≠', 'yes', 'dale']:
                    state.update('SHOW_LOAN')
                    return ("üí∞ Basado en tu an√°lisis, podr√≠as calificar para un pr√©stamo.\n\n"
                           "¬øDeseas que te contacte un asesor? (s√≠/no)")
                else:
                    state.update('DONE')
                    return "üëç ¬°Gracias por usar FinGro! Si necesitas otro an√°lisis, escribe 'reiniciar'."
                    
            elif state.state == 'SHOW_LOAN':
                if message in ['si', 's√≠', 'yes', 'dale']:
                    state.update('DONE')
                    return ("‚úÖ ¬°Perfecto! Un asesor te contactar√° pronto.\n\n"
                           "Si necesitas otro an√°lisis, escribe 'reiniciar'.")
                else:
                    state.update('DONE')
                    return "üëç ¬°Gracias por usar FinGro! Si necesitas otro an√°lisis, escribe 'reiniciar'."
            
            else:
                state.update('START')
                return "üëã ¬°Bienvenido a FinGro!\n\n¬øQu√© cultivo planeas sembrar?"
                
        except Exception as e:
            logger.error(f"Error en _process_state: {str(e)}")
            raise
    
    async def _get_state(self, phone: str) -> ConversationState:
        """Obtiene el estado de la conversaci√≥n"""
        try:
            data = await firebase_manager.get_conversation_state(phone)
            if data:
                return ConversationState.from_dict(data)
            return ConversationState()
        except Exception as e:
            logger.error(f"Error obteniendo estado: {str(e)}")
            raise
            
    async def _save_state(self, phone: str, state: ConversationState):
        """Guarda el estado de la conversaci√≥n"""
        try:
            await firebase_manager.update_user_state(phone, state.to_dict())
        except Exception as e:
            logger.error(f"Error guardando estado: {str(e)}")
            raise
            
    async def _reset_state(self, phone: str):
        """Reinicia el estado de la conversaci√≥n"""
        try:
            state = ConversationState()
            await self._save_state(phone, state)
        except Exception as e:
            logger.error(f"Error reiniciando estado: {str(e)}")
            raise
    
    def _get_help_message(self, current_state: str) -> str:
        """Obtiene el mensaje de ayuda seg√∫n el estado actual"""
        help_messages = {
            'GET_CROP': "üå± Por favor ingresa el tipo de cultivo que planeas sembrar, por ejemplo: ma√≠z, frijol, papa, etc.",
            'GET_AREA': "üìè Ingresa el n√∫mero de hect√°reas que planeas sembrar. Debe ser un n√∫mero mayor a 0.",
            'GET_CHANNEL': "üè™ Selecciona c√≥mo planeas vender tu cosecha: mayorista, cooperativa, exportaci√≥n o mercado local.",
            'GET_IRRIGATION': "üíß Indica el sistema de riego que usar√°s: gravedad, aspersi√≥n, goteo o temporal (lluvia).",
            'GET_LOCATION': "üìç Ingresa el departamento donde est√° ubicado el terreno.",
            'default': "üëã FinGro te ayuda a analizar la viabilidad de tu proyecto agr√≠cola. Escribe 'reiniciar' para comenzar."
        }
        return help_messages.get(current_state, help_messages['default'])

# Instancia global
conversation_flow = ConversationFlow()
